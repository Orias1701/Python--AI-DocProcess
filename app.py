"""
FastAPI gateway for your appCalled pipeline.

‚úÖ Gi·ªØ nguy√™n pipeline g·ªëc (appCalled.py)
‚úÖ T∆∞∆°ng th√≠ch Hugging Face Spaces (Docker)
‚úÖ C√≥ Bearer token, Swagger UI (/docs)
‚úÖ Endpoint: /, /health, /process_pdf, /search, /summarize
"""

import os
import time
from typing import Optional

from fastapi import FastAPI, UploadFile, File, HTTPException, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel

# -------------------------
# üîí Bearer token (optional)
# -------------------------
API_SECRET = os.getenv("API_SECRET", "").strip()

def require_bearer(authorization: Optional[str] = Header(None)):
    """Ki·ªÉm tra Bearer token n·∫øu b·∫≠t API_SECRET."""
    if not API_SECRET:
        return  # Kh√¥ng b·∫≠t x√°c th·ª±c
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing Bearer token")
    token = authorization.split(" ", 1)[1].strip()
    if token != API_SECRET:
        raise HTTPException(status_code=403, detail="Invalid token")

# -------------------------
# üß© Import project modules
# -------------------------
try:
    import appCalled as APP_CALLED
    print("‚úÖ ƒê√£ load appCalled.")
except Exception as e:
    APP_CALLED = None
    print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ import appCalled: {e}")

# -------------------------
# üöÄ Init FastAPI
# -------------------------
app = FastAPI(
    title="Document AI API (FastAPI)",
    version="2.0.0",
    description="API x·ª≠ l√Ω PDF: tr√≠ch xu·∫•t, t√≥m t·∫Øt, t√¨m ki·∫øm, ph√¢n lo·∫°i.",
)

# Cho ph√©p g·ªçi API t·ª´ web client
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# -------------------------
# üè† Root endpoint (tr√°nh 404 tr√™n Spaces)
# -------------------------
@app.get("/")
def root():
    """Trang ch√†o m·ª´ng / ki·ªÉm tra tr·∫°ng th√°i."""
    return {
        "message": "üìò Document AI API ƒëang ch·∫°y.",
        "status": "ok",
        "docs": "/docs",
        "endpoints": ["/process_pdf", "/search", "/summarize", "/health"],
    }

# -------------------------
# ü©∫ /health
# -------------------------
@app.get("/health")
def health(_=Depends(require_bearer)):
    """Ki·ªÉm tra tr·∫°ng th√°i ho·∫°t ƒë·ªông."""
    return {
        "status": "ok",
        "time": time.time(),
        "appCalled": bool(APP_CALLED),
        "has_fileProcess": hasattr(APP_CALLED, "fileProcess") if APP_CALLED else False,
    }

# -------------------------
# üìò /process_pdf
# -------------------------
@app.post("/process_pdf")
async def process_pdf(file: UploadFile = File(...), _=Depends(require_bearer)):
    """Nh·∫≠n file PDF ‚Üí ch·∫°y appCalled.fileProcess ‚Üí tr·∫£ v·ªÅ summary + category."""
    if not file.filename.lower().endswith(".pdf"):
        raise HTTPException(status_code=400, detail="Ch·ªâ ch·∫•p nh·∫≠n file PDF.")

    pdf_bytes = await file.read()

    if not APP_CALLED or not hasattr(APP_CALLED, "fileProcess"):
        raise HTTPException(status_code=500, detail="Kh√¥ng t√¨m th·∫•y appCalled.fileProcess().")

    try:
        result = APP_CALLED.fileProcess(pdf_bytes)
        return {
            "status": "success",
            "checkstatus": result.get("checkstatus"),
            "summary": result.get("summary"),
            "category": result.get("category"),
            "top_candidates": result.get("reranked", []),
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"L·ªói x·ª≠ l√Ω PDF: {str(e)}")

# -------------------------
# üîç /search
# -------------------------
class SearchIn(BaseModel):
    query: str
    k: int = 10

@app.post("/search")
def search(body: SearchIn, _=Depends(require_bearer)):
    """T√¨m ki·∫øm b·∫±ng FAISS + Rerank t·ª´ appCalled.runSearch()."""
    q = (body.query or "").strip()
    if not q:
        raise HTTPException(status_code=400, detail="query kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")

    if not APP_CALLED or not hasattr(APP_CALLED, "runSearch"):
        raise HTTPException(status_code=500, detail="Kh√¥ng t√¨m th·∫•y appCalled.runSearch().")

    try:
        results = APP_CALLED.runSearch(q)
        if isinstance(results, list):
            formatted = results[:body.k]
        elif isinstance(results, dict) and "results" in results:
            formatted = results["results"][:body.k]
        else:
            formatted = [str(results)]
        return {"status": "success", "results": formatted}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"L·ªói t√¨m ki·∫øm: {str(e)}")

# -------------------------
# üß† /summarize
# -------------------------
class SummIn(BaseModel):
    text: str
    minInput: int = 256
    maxInput: int = 1024

@app.post("/summarize")
def summarize_text(body: SummIn, _=Depends(require_bearer)):
    """T√≥m t·∫Øt vƒÉn b·∫£n b·∫±ng appCalled.summarizer_engine."""
    text = (body.text or "").strip()
    if not text:
        raise HTTPException(status_code=400, detail="text kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng")

    if not APP_CALLED or not hasattr(APP_CALLED, "summarizer_engine"):
        raise HTTPException(status_code=500, detail="Kh√¥ng t√¨m th·∫•y appCalled.summarizer_engine.")

    try:
        summarized = APP_CALLED.summarizer_engine.summarize(
            text, minInput=body.minInput, maxInput=body.maxInput
        )
        return {"status": "success", "summary": summarized.get("summary_text", "")}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"L·ªói t√≥m t·∫Øt: {str(e)}")
